import time
import logging
logger = logging.getLogger('main') # use logger instead of printing



def wait_for_results(script_name, path, num_of_expected_results, error_file_path, suffix='_features_and_predictions.csv',
                     remove=False, time_to_wait=10, start=0, error_message=None):
    '''waits until path contains num_of_expected_results $suffix files'''
    if not start:
        start = time.ctime()
    logger.info(f'Waiting for {script_name}...\nContinues when {num_of_expected_results} results will be in:\n{path}')
    if num_of_expected_results == 0:
        if error_message:
            fail(error_message, error_file_path)
        raise ValueError(f'\n{"#"*100}\nNumber of expected results is {num_of_expected_results}! Something went wrong in the previous analysis steps...\n{"#"*100}')
    total_time = 0
    i = 0
    current_num_of_results = 0
    while num_of_expected_results > current_num_of_results:
        assert not os.path.exists(error_file_path)
        try:
            current_num_of_results = sum(1 for x in os.listdir(path) if x.endswith(suffix))
        except:
            logger.info(f'Could not run the following command, probably due to some system error...')
            logger.info(f'current_num_of_results = sum(1 for x in os.listdir({path}) if x.endswith({suffix}))')
        jobs_left = num_of_expected_results - current_num_of_results
        sleep(time_to_wait)
        total_time += time_to_wait
        i += 1
        if i % 5 == 0:  # print status every 5 cycles of $time_to_wait
            logger.info(f'\t{measure_time(total_time)} have passed since started waiting ({num_of_expected_results} - {current_num_of_results} = {jobs_left} more files are still missing)')
    time.ctime()
    logger.info(f'Done waiting for:\n{script_name}\n(took {measure_time(int(end-start))}).\n')
    assert not os.path.exists(error_file_path)


def fail(error_msg, error_file_path):
    with open(error_file_path, 'w') as error_f:
        error_f.write(error_msg + '\n')
    raise Exception(error_msg)


def update_html(html_path, src, dst):
    # The initial file exists (generated by the cgi) so we can read and parse it.
    with open(html_path) as f:
        html_content = f.read()
    html_content = html_content.replace(src, dst)
    with open(html_path, 'w') as f:
        f.write(html_content)


def append_to_html(html_path, new_content):
    with open(html_path) as f:
        html_content = f.read()
    html_content += new_content
    with open(html_path, 'w') as f:
        f.write(html_content)


def create_dir(path):
    import os
    if not os.path.exists(path):
        logger.info(f'Creating directory: {path}')
        os.makedirs(path)
    else:
        logger.info(f'Directory already exists: {path}')


